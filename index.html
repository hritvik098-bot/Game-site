<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>The Haunted One (Mobile Horror)</title>
  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden;font-family:system-ui,Arial}
    canvas{display:block;touch-action:none;background:#050505}
    #hud{
      position:fixed;left:10px;top:10px;z-index:10;
      background:rgba(0,0,0,.55);color:#fff;padding:10px 12px;border-radius:14px;
      font-size:13px;max-width:92vw;line-height:1.35
    }
    #hud b{font-size:14px}
    #msg{
      position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:30;
      background:rgba(0,0,0,.72);color:#fff;text-align:center;padding:20px
    }
    #msgBox{
      background:rgba(0,0,0,.65);border:1px solid rgba(255,255,255,.15);
      padding:18px;border-radius:18px;max-width:92vw
    }
    #msgBox h2{margin:0 0 10px;font-size:20px}
    #msgBox p{margin:0 0 14px;font-size:14px;opacity:.95}
    #btnStart{
      display:inline-block;padding:10px 14px;border-radius:14px;
      background:#fff;color:#000;font-weight:700;border:none
    }

    /* Mobile controls */
    #controls{position:fixed;inset:0;pointer-events:none;z-index:20}
    #joyBase{
      position:fixed;left:18px;bottom:18px;width:150px;height:150px;border-radius:999px;
      background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.10);
      pointer-events:auto
    }
    #joyKnob{
      position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
      width:70px;height:70px;border-radius:999px;background:rgba(255,255,255,.18);
      border:1px solid rgba(255,255,255,.15)
    }
    #btns{
      position:fixed;right:18px;bottom:18px;display:flex;flex-direction:column;gap:10px;
      pointer-events:auto
    }
    .btn{
      width:90px;height:90px;border-radius:18px;
      background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.10);
      display:flex;align-items:center;justify-content:center;color:#fff;
      font-weight:800;user-select:none
    }
    .btnSmall{width:90px;height:70px}
    .hint{opacity:.9}
  </style>
</head>
<body>

<div id="hud">
  <b>The Haunted One (Mobile Horror)</b><br>
  <span class="hint">Goal:</span> Reach the <b>EXIT DOOR</b> ðŸšª<br>
  <span class="hint">Controls:</span> Joystick = Move â€¢ RUN â€¢ Flashlight (F)
</div>

<div id="msg">
  <div id="msgBox">
    <h2 id="msgTitle">The Haunted One</h2>
    <p id="msgText">Tap Start to play.</p>
    <button id="btnStart">START</button>
  </div>
</div>

<canvas id="c"></canvas>

<div id="controls">
  <div id="joyBase"><div id="joyKnob"></div></div>
  <div id="btns">
    <div class="btn btnSmall" id="btnF">F</div>
    <div class="btn btnSmall" id="btnRun">RUN</div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const msg = document.getElementById('msg');
  const msgTitle = document.getElementById('msgTitle');
  const msgText = document.getElementById('msgText');
  const btnStart = document.getElementById('btnStart');

  function resize(){
    canvas.width = innerWidth * devicePixelRatio;
    canvas.height = innerHeight * devicePixelRatio;
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }
  addEventListener('resize', resize);
  resize();

  // ===== Game World =====
  const W = 2200, H = 2200; // world size
  const walls = [];
  function addWall(x,y,w,h){ walls.push({x,y,w,h}); }

  // Maze walls
  addWall(0,0,W,40); addWall(0,H-40,W,40); addWall(0,0,40,H); addWall(W-40,0,40,H);
  addWall(200,200,40,1700);
  addWall(200,200,1500,40);
  addWall(1660,200,40,1400);
  addWall(420,520,1200,40);
  addWall(420,520,40,1100);
  addWall(420,1620,900,40);
  addWall(1320,900,40,760);
  addWall(760,900,600,40);

  const exitDoor = {x: W-160, y: H-160, w: 80, h: 80};

  const player = {x: 120, y: 120, r: 18, spd: 2.2};
  const enemy  = {x: W-320, y: 220, r: 22, spd: 1.7};

  let flashlight = false;
  let running = false;
  let started = false;
  let gameOver = false;

  // ===== Controls (Joystick + buttons) =====
  const joyBase = document.getElementById('joyBase');
  const joyKnob = document.getElementById('joyKnob');
  const btnF = document.getElementById('btnF');
  const btnRun = document.getElementById('btnRun');

  let joyActive=false, joyCx=0, joyCy=0, joyDx=0, joyDy=0;

  function setKnob(dx,dy){
    const max=45;
    const len=Math.hypot(dx,dy)||1;
    const cl=Math.min(len,max);
    const nx=dx/len*cl, ny=dy/len*cl;
    joyKnob.style.transform = `translate(${nx}px,${ny}px) translate(-50%,-50%)`;
    joyDx = nx/max;
    joyDy = ny/max;
  }

  joyBase.addEventListener('pointerdown', e=>{
    joyActive=true; joyBase.setPointerCapture(e.pointerId);
    const r=joyBase.getBoundingClientRect();
    joyCx=r.left+r.width/2; joyCy=r.top+r.height/2;
    setKnob(e.clientX-joyCx, e.clientY-joyCy);
  });
  joyBase.addEventListener('pointermove', e=>{
    if(!joyActive) return;
    setKnob(e.clientX-joyCx, e.clientY-joyCy);
  });
  joyBase.addEventListener('pointerup', ()=>{
    joyActive=false;
    joyKnob.style.transform = `translate(0px,0px) translate(-50%,-50%)`;
    joyDx=0; joyDy=0;
  });

  const hold = (el, onDown, onUp) => {
    el.addEventListener('pointerdown', e=>{e.preventDefault(); onDown();});
    el.addEventListener('pointerup', e=>{e.preventDefault(); onUp();});
    el.addEventListener('pointercancel', e=>{e.preventDefault(); onUp();});
    el.addEventListener('pointerleave', e=>{ /* ignore */ });
  };

  hold(btnRun, ()=> running=true, ()=> running=false);

  btnF.addEventListener('pointerdown', e=>{
    e.preventDefault();
    flashlight = !flashlight;
    btnF.style.background = flashlight ? "rgba(255,255,255,.20)" : "rgba(255,255,255,.08)";
  });

  // PC keyboard support
  const keys = {};
  addEventListener('keydown', e=>{
    keys[e.key.toLowerCase()] = true;
    if(e.key === 'Shift') running = true;
    if(e.key.toLowerCase() === 'f'){
      flashlight = !flashlight;
      btnF.style.background = flashlight ? "rgba(255,255,255,.20)" : "rgba(255,255,255,.08)";
    }
  });
  addEventListener('keyup', e=>{
    keys[e.key.toLowerCase()] = false;
    if(e.key === 'Shift') running = false;
  });

  // ===== Collision =====
  function circleRectCollide(cx,cy,r, rect){
    const rx=rect.x, ry=rect.y, rw=rect.w, rh=rect.h;
    const nx=Math.max(rx, Math.min(cx, rx+rw));
    const ny=Math.max(ry, Math.min(cy, ry+rh));
    const dx=cx-nx, dy=cy-ny;
    return dx*dx+dy*dy < r*r;
  }

  function moveWithWalls(obj, vx, vy){
    obj.x += vx;
    for(const w of walls){
      if(circleRectCollide(obj.x,obj.y,obj.r,w)){
        obj.x -= vx;
        break;
      }
    }
    obj.y += vy;
    for(const w of walls){
      if(circleRectCollide(obj.x,obj.y,obj.r,w)){
        obj.y -= vy;
        break;
      }
    }
  }

  function inExit(){
    return circleRectCollide(player.x, player.y, player.r, exitDoor);
  }

  function dist(a,b){
    const dx=a.x-b.x, dy=a.y-b.y;
    return Math.hypot(dx,dy);
  }

  // ===== Camera =====
  function cam(){
    const pad = 260;
    const cx = Math.max(pad, Math.min(player.x, W-pad));
    const cy = Math.max(pad, Math.min(player.y, H-pad));
    return {x: cx - innerWidth/2, y: cy - innerHeight/2};
  }

  // ===== Drawing =====
  function draw(){
    ctx.clearRect(0,0,innerWidth,innerHeight);
    const c = cam();

    // floor
    ctx.fillStyle = "#060606";
    ctx.fillRect(0,0,innerWidth,innerHeight);

    // grid
    ctx.globalAlpha = 0.15;
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 1;
    const step = 80;
    for(let x = -((c.x)%step); x<innerWidth; x+=step){
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,innerHeight); ctx.stroke();
    }
    for(let y = -((c.y)%step); y<innerHeight; y+=step){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(innerWidth,y); ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // walls
    ctx.fillStyle = "#121212";
    for(const w of walls){
      ctx.fillRect(w.x-c.x, w.y-c.y, w.w, w.h);
    }

    // exit
    ctx.fillStyle = "#1d5";
    ctx.fillRect(exitDoor.x-c.x, exitDoor.y-c.y, exitDoor.w, exitDoor.h);
    ctx.fillStyle="#000";
    ctx.font="bold 14px system-ui";
    ctx.fillText("EXIT", exitDoor.x-c.x+18, exitDoor.y-c.y+48);

    // enemy
    ctx.beginPath();
    ctx.fillStyle = "#b11";
    ctx.arc(enemy.x-c.x, enemy.y-c.y, enemy.r, 0, Math.PI*2);
    ctx.fill();

    // player
    ctx.beginPath();
    ctx.fillStyle = "#ddd";
    ctx.arc(player.x-c.x, player.y-c.y, player.r, 0, Math.PI*2);
    ctx.fill();

    // flashlight effect (darkness + cone)
    ctx.fillStyle = "rgba(0,0,0,.70)";
    ctx.fillRect(0,0,innerWidth,innerHeight);

    if(flashlight){
      ctx.globalCompositeOperation = "destination-out";
      ctx.beginPath();
      ctx.arc(player.x-c.x, player.y-c.y, 230, 0, Math.PI*2);
      ctx.fill();
      ctx.globalCompositeOperation = "source-over";
    } else {
      ctx.globalCompositeOperation = "destination-out";
      ctx.beginPath();
      ctx.arc(player.x-c.x, player.y-c.y, 120, 0, Math.PI*2);
      ctx.fill();
      ctx.globalCompositeOperation = "source-over";
    }

    // vignette
    const grd = ctx.createRadialGradient(innerWidth/2, innerHeight/2, 50, innerWidth/2, innerHeight/2, Math.max(innerWidth,innerHeight)/1.1);
    grd.addColorStop(0,"rgba(0,0,0,0)");
    grd.addColorStop(1,"rgba(0,0,0,.55)");
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,innerWidth,innerHeight);
  }

  // ===== Game loop =====
  function tick(){
    if(!started){ draw(); requestAnimationFrame(tick); return; }
    if(gameOver){ draw(); requestAnimationFrame(tick); return; }

    // movement vector
    let vx = 0, vy = 0;

    // mobile joystick
    vx += joyDx;
    vy += joyDy;

    // pc keys
    if(keys['w']) vy -= 1;
    if(keys['s']) vy += 1;
    if(keys['a']) vx -= 1;
    if(keys['d']) vx += 1;

    // normalize
    const len = Math.hypot(vx,vy) || 1;
    vx/=len; vy/=len;

    const spd = player.spd * (running ? 1.65 : 1);
    moveWithWalls(player, vx*spd, vy*spd);

    // enemy chase
    const dx = player.x-enemy.x;
    const dy = player.y-enemy.y;
    const d = Math.hypot(dx,dy) || 1;
    const eSpd = enemy.spd * (flashlight ? 1.25 : 1.05);

    // enemy avoid walls (simple)
    moveWithWalls(enemy, (dx/d)*eSpd, (dy/d)*eSpd);

    // lose if enemy touches
    if(dist(player,enemy) < (player.r+enemy.r)-2){
      gameOver = true;
      msgTitle.textContent = "ðŸ’€ The Haunted One";
      msgText.textContent = "You got caught! Tap START to try again.";
      msg.style.display = "flex";
      btnStart.textContent = "RESTART";
    }

    // win
    if(inExit()){
      gameOver = true;
      msgTitle.textContent = "âœ… You Escaped!";
      msgText.textContent = "You reached the EXIT DOOR ðŸšª Tap START to play again.";
      msg.style.display = "flex";
      btnStart.textContent = "PLAY AGAIN";
    }

    draw();
    requestAnimationFrame(tick);
  }

  function resetGame(){
    player.x = 120; player.y = 120;
    enemy.x = W-320; enemy.y = 220;
    running = false;
    gameOver = false;
    flashlight = false;
    btnF.style.background = "rgba(255,255,255,.08)";
  }

  // Start overlay
  msg.style.display = "flex";
  msgTitle.textContent = "The Haunted One (Mobile Horror)";
  msgText.textContent = "Joystick se move karo, RUN dabao, F se flashlight. EXIT door tak pahucho!";
  btnStart.textContent = "START";

  btnStart.onclick = () => {
    if(!started){
      started = true;
    }
    resetGame();
    msg.style.display = "none";
  };

  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
